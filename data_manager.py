# Pymongo helps make it easy to connect to MongoDB and perform CRUD operations.
import os
import openai
import pymongo
from typing import Any, Dict, List
# The Collection class is used to access the MongoDB collection which is like a table in a relational database.
from pymongo.collection import Collection

# My interfaces
from IDataManager import IDataManager


class DataManager(IDataManager):
    # Initilize the QADataManager with the MongoDB URI and get a reference to the QA collection.
    def __init__(self):
        self.mongo_client = pymongo.MongoClient(os.environ["MONGO_URI"])
        self.qa_collection: Collection = self.mongo_client["cncTechnicalAi"]["qa"]

    # Method to add a QA pair to the database. It should convert the question to a vector and store it in the database to be used for vector search.
    # The answer should be stored as is for now. It may be converted to a vector later if we want to use vector search for answers as well.
    def create(self, data: Dict[str, Any]) -> None:
        # Generate embeddings for the question
        embeddings = self.create_vector_embeddings(data["question"])
        # Store question, answer, and embeddings in MongoDB
        self.qa_collection.insert_one(
            {
                "question": data["question"],
                "answer": data["answer"],
                "vector": embeddings,
            }
        )

    # Method to get a QA pair from the database by its ID. The ID is generated by MongoDB when the document is inserted.
    def get(self, id: Any) -> Dict[str, Any]:
        return self.qa_collection.find_one({"_id": id})

    # Method to update a QA pair in the database. Should also convert the new question to a vector to be used for vector search.
    def update(self, id: Any, data: Dict[str, Any]) -> None:
        self.qa_collection.update_one(
            {"_id": id},
            {"$set": {"question": data["question"], "answer": data["answer"]}},
        )

    def find(self, query: Dict[str, Any]) -> List[Dict[str, Any]]:
        # Generate embeddings for the query
        query_vector = self.create_vector_embeddings(query["question"])
        # Perform vector search
        search_query = {
            "$vectorSearch": {
                "index": "your_index_name",
                "query": query_vector
                # Additional parameters as needed
            }
        }
        return list(self.qa_collection.aggregate([search_query]))

    def delete(self, id: Any) -> None:
        self.qa_collection.delete_one({"_id": id})

    # Method to create a vector search index in the MongoDB collection
    def create_vector_search_index(
        self,
        index_name,  # The name of the index
        vector_field_name,  # The field name of the vectors
        num_dimensions,  # The number of dimensions of the vectors
        similarity,  # The similarity metric to use (e.g., "cosine", "dotProduct")
        filter_field_name=None,  # An optional field name to filter the results
    ):
        # Define the index
        index_definition = {
            "name": index_name,
            "type": "vectorSearch",  # This is a vector search index
            "fields": [
                {
                    "type": "vector",  # This field is a vector
                    "path": vector_field_name,  # The field name of the vectors
                    "numDimensions": num_dimensions,  # The number of dimensions of the vectors
                    "similarity": similarity,  # The similarity metric to use
                }
            ],
        }

        # If a filter field name is provided, add it to the index definition
        if filter_field_name:
            index_definition["fields"].append(
                {"type": "filter", "path": filter_field_name}  # This field is a filter
            )

        # Create the index in the MongoDB collection
        self.qa_collection.create_index(index_definition)

    # Method to perform a vector search in the MongoDB collection
    def vector_search(self, index_name, query_vector, filter_query=None):
        # Define the search query
        search_query = {"$vectorSearch": {"index": index_name, "query": query_vector}}

        # If a filter query is provided, add it to the search query
        if filter_query:
            search_query["$vectorSearch"]["filter"] = filter_query

        # Perform the search and return the results
        return self.qa_collection.aggregate([search_query])

    def create_vector_embeddings(self, text):
        # Use an ML model or API to generate embeddings
        # Example using OpenAI's Embedding API (pseudo-code)
        response = openai.Embedding.create(
            input=[text], model="text-embedding-model-name"
        )
        embeddings = response["data"][0]["embedding"]
        return embeddings

    def create(self, question, answer):
        # Generate embeddings for the question
        embeddings = self.create_vector_embeddings(question)
        # Store question, answer, and embeddings in MongoDB
        self.qa_collection.insert_one(
            {"question": question, "answer": answer, "vector": embeddings}
        )

    def vector_search(self, query_text):
        # Generate embeddings for the query
        query_vector = self.create_vector_embeddings(query_text)
        # Perform vector search
        search_query = {
            "$vectorSearch": {
                "index": "your_index_name",
                "query": query_vector
                # Additional parameters as needed
            }
        }
        return self.qa_collection.aggregate([search_query])
